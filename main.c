/******************************************************************************
* File Name:   		main.c
*
* Description: 		Main file of the IMR Robot Control see doctrings or README.md for
*              		Details.
*
* Related Document: See README.md
* 
* Authors: 		Granig Jonas (PSS SIS UPC) & Schmidt Michael (IFAT PSS AIS SAE)                                                               
*
*******************************************************************************
*
* Copyright (c) 2024, Infineon Technologies AG
* All rights reserved.
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
*****************************************************************************/

#include "IMR_CAN_GLOBAL.h"
#include "cybsp.h"
#include "cy_utils.h"
#include "Libraries/CAN/IMR_CAN.h"
#include "Libraries/IMRRC.h"
#include "Libraries/IMRMecanum.h"
#include <stdint.h>
#include <stdlib.h>

uint8_t RC_failsafe = 0;
int16_t remote_v[3] = { 0 , 0 , 0 };		// Trajectory values from RC
RCinput_t RemoteControl_IN;
int16_t wS[4]; 
extern float encoderSpeed[4];

/***
 * 
 * Timer Interrupt
 * 
 * - Called every 100ms to send current wheelspeeds to the Motor Control
 * 
 ***/

void TIMER_TIMEOUT_PERIOD_MATCH_EVENT_HANDLER(void) {
	uint8_t CANBuffer[6];
	XMC_CAN_STATUS_t sendStatus;
	int16_t motorOutput[4] = { 0 };

	applyFIRFilter(wS, motorOutput);

	CANBuffer[0] = (uint8_t)  ((((int16_t) (motorOutput[0] * 1) & 0xFF00) >> 8) & 0xFF);
	CANBuffer[1] = (uint8_t) 	((int16_t) (motorOutput[0] * 1) & 0xFF);
	sendStatus = CAN_TX_Request(MOT_FL_SPEED_COMMAND, CANBuffer, 2);
	CANBuffer[0] = (uint8_t)  ((((int16_t) (motorOutput[1] * 1) & 0xFF00) >> 8) & 0xFF);
	CANBuffer[1] = (uint8_t) 	((int16_t) (motorOutput[1] * 1) & 0xFF);
	sendStatus = CAN_TX_Request(MOT_FR_SPEED_COMMAND, CANBuffer, 2);
	CANBuffer[0] = (uint8_t)  ((((int16_t) (motorOutput[2] * 1) & 0xFF00) >> 8) & 0xFF);
	CANBuffer[1] = (uint8_t) 	((int16_t) (motorOutput[2] * 1) & 0xFF);
	sendStatus = CAN_TX_Request(MOT_BL_SPEED_COMMAND, CANBuffer, 2);
	CANBuffer[0] = (uint8_t)  ((((int16_t) (motorOutput[3] * 1) & 0xFF00) >> 8) & 0xFF);
	CANBuffer[1] = (uint8_t) 	((int16_t) (motorOutput[3] * 1) & 0xFF);
	sendStatus = CAN_TX_Request(MOT_BR_SPEED_COMMAND, CANBuffer, 2);

	memset(wS,0,8);

	if(Trajectory_ttl > 0U) {
		if((RC_failsafe > 0 && RemoteControl_IN.Switch_SD == 1) || RC_failsafe == 0){	// processing the trajectory CAN command
			int16_t vel[3];	// Robot target velocity
			can2Vel(Trajectory_data, vel);
			inverseKinematics(vel, wS);
		}
		Trajectory_ttl--;
	}

	// Sending Odometry
	int16_t v_odo[3]; // Odometry estimate
	estimateOdometry(encoderSpeed, v_odo);
	CANBuffer[0] = (uint8_t) ((v_odo[0] & 0xFF00) >> 8);
	CANBuffer[1] = (uint8_t) (v_odo[0] & 0xFF);
	CANBuffer[2] = (uint8_t) ((v_odo[1] & 0xFF00) >> 8);
	CANBuffer[3] = (uint8_t) (v_odo[1] & 0xFF);
	CANBuffer[4] = (uint8_t) ((v_odo[2] & 0xFF00) >> 8);
	CANBuffer[5] = (uint8_t) (v_odo[2] & 0xFF);
	CAN_TX_Request(ROBOT_ODOMETRY_ESTIMATE, CANBuffer, 6);


	if(sendStatus == CAN_STATUS_NODE_BUSY){
		XMC_GPIO_SetOutputHigh(LED_Blue_PORT,LED_Blue_PIN);
	} else XMC_GPIO_SetOutputLow(LED_Blue_PORT,LED_Blue_PIN);
}

/***
 * 
 * MAIN METHOD
 * 
 ***/
int main(void)
{
    cy_rslt_t result;

    /* Initialize the device and board peripherals */
    result = cybsp_init();
	
	CAN_Initialize();
	XMC_GPIO_SetOutputHigh(LED_Blue_PORT,LED_Blue_PIN);
	XMC_GPIO_SetOutputHigh(LED_Green_PORT,LED_Green_PIN);
	XMC_UART_CH_EnableInputInversion(SBUS_UART_HW, XMC_UART_CH_INPUT_RXD);

    XMC_CCU4_SLICE_StartTimer(TIMER_TIMEOUT_HW);
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

	if(false)  // enable/disable for static LED display.
	{
		RCinput_t input;
		input.Switch_SB = 1; // select color
		input.Switch_SA = 1; // pulsing
		readLEDinput(input);
	}

    // LOOP
    while(1U)
    {
	    if(SBUSRX_Parse() && !BMS_PowerReduced){
		    RemoteControl_IN = Process_RC_Inputs(sbus_data);
			
		    if(sbus_data.failsafe == false) RC_failsafe = RC_TIME_TO_LIVE;

		    readLEDinput(RemoteControl_IN); 							// delete for not using LED control via RemoteControl

		    memset(remote_v,0,6);
		    if(RemoteControl_IN.Switch_SD == 3 && sbus_data.lost_frame == false) {	// Switch D Must be enabled (Dead man switch)

			    remote_v[0] = RemoteControl_IN.RightStick_UpDown*10922/100;
			    remote_v[1] = -RemoteControl_IN.RightStick_LeftRight*10922/100;
			    remote_v[2] = (int16_t) RemoteControl_IN.LeftStick_LeftRight*5215/100*2;
			    if(remote_v[0] || remote_v[1] || remote_v[2]) {
				      inverseKinematics(remote_v, wS);
			    }
			    
		    }
			XMC_GPIO_SetOutputHigh(LED_Green_PORT, LED_Green_PIN);

	    } else if(RC_failsafe != 0) {								// Green OnBoard LED will be off if no RC commands are received after TTL.
		    RC_failsafe--; 
		    XMC_GPIO_SetOutputLow(LED_Green_PORT, LED_Green_PIN);
	    }
	    memset(remote_v,0,6);

    }
}

/* [] END OF FILE */
